using DelimitedFiles
using DifferentialEquations

# Read in velocity initial conditions generated by generateVelocityIC.jl
# Require N odd (for now)
function readVelocityIC(file)
	vel = readdlm(file, ',', Float64)
	N = Int(sqrt(length(vel)/2))
	return reshape(vel, N, N, 2), Int((N - 1)/2)
end

# Computes curl of 2d vector field using central differences
function curl(u)
	N = size(u)[1]
	delta = 2*pi/N

	u1 = u[:,:,1]
	u2 = u[:,:,2]
	du1_dy = (circshift(u1, (0, 1)) - circshift(u1, (0, -1)))/(2*delta)
	du2_dx = (circshift(u2, (1, 0)) - circshift(u2, (-1, 0)))/(2*delta)
	return du1_dy - du2_dx
end

# Compute a dict of all triples j,k,l in [-N,N] such that j+k+l=0
function computeTriples(N)
	# Consider an immutable dict for speed
	triples = Dict{Int64, Tuple{Int64,Int64,Int64}}()
	counter = 1

	# Consider storing j,k,l in increasing order to save 6x space and some time
	# Only need to store half because of rfft properties
	for j = -N:N
		for k = -N:N
			l = - j - k
			if -N <= l <= N
				triples[counter] = (j,k,l)
				counter += 1
			end
		end
	end
	return triples
end


# Uniformly at random selects j,k,l in [-N, N]^2 such that j+k+l=(0,0)
function randomTriple(triples)
	j = Array{Int64}(undef, 2)
	k = Array{Int64}(undef, 2)
	l = Array{Int64}(undef, 2)

	X = rand(1:length(triples), 2)

	for i = 1:2
		j[i] = triples[X[i]][1]
		k[i] = triples[X[i]][2]
		l[i] = triples[X[i]][3]
	end
	return j, k, l
end

# Uniformly at random selects j,k,l in [-N, N]^2 such that j+k+l=(0,0)
# Does not require dictionary of triples
# "Good" runtime in expectation (no analysis done yet but easily > 50% chance of success)
function selectTripleRejectionSampler()
	# todo
	return 0
end


# Solves coupled ODE for time t
function evolve!(qhat, j, k, l, t)
	N = size(qhat)[2]

	C_jl = coef(j,l)
	C_lk = coef(l,k)
	C_kj = coef(k,j)

	if j[1] >= 0
		qj = qhat[j[1]+1, mod(j[2], N)+1]
	else
		qj = conj(qhat[-j[1]+1, mod(-j[2], N)+1])
	end

	if k[1] >= 0
		qk = qhat[k[1]+1, mod(k[2], N)+1]
	else
		qk = conj(qhat[-k[1]+1, mod(-k[2], N)+1])
	end

	if l[1] >= 0
		ql = qhat[l[1]+1, mod(l[2], N)+1]
	else
		ql = conj(qhat[-l[1]+1, mod(-l[2], N)+1])
	end


	tspan = (0.0, t)
	prob = ODEProblem(ODEsystem!, [qj, qk, ql], tspan, [C_jl, C_lk, C_kj])
	sol = solve(prob)

	qj, qk, ql = sol[end]

	if j[1] >= 0
		qhat[j[1]+1, mod(j[2], N)+1] = qj
	else
		qhat[-j[1]+1, mod(-j[2], N)+1] = conj(qj)
	end

	if k[1] >= 0
		qhat[k[1]+1, mod(k[2], N)+1] = qk
	else
		qhat[-k[1]+1, mod(-k[2], N)+1] = conj(qk)
	end

	if l[1] >= 0
		qhat[l[1]+1, mod(l[2], N)+1] = ql
	else
		qhat[-l[1]+1, mod(-l[2], N)+1] = conj(ql)
	end
end

# Coupled ODE
function ODEsystem!(dq, q, p, t)
	C_jl, C_lk, C_kj = p
	dq[1] = -conj(C_jl*q[2]*q[3])
	dq[2] = -conj(C_lk*q[1]*q[3])
	dq[3] = -conj(C_kj*q[1]q[2])
end

# Returns C_{l,j}
function coef(l,j)
	if l == [0,0] || j == [0,0]
		return 0
	end
	return (-j[2]*l[1] + j[1]*l[2])/(4*pi) * (1/(l[1]^2+l[2]^2) - 1/(j[1]^2+j[2]^2))
end