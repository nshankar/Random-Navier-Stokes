using DelimitedFiles
using DifferentialEquations

# Read in velocity initial conditions generated by generateVelocityIC.jl
# Require N odd (for now)
function readVelocityIC(file)
	vel = readdlm(file, ',', Float64)
	N = Int(sqrt(length(vel)/2))
	return reshape(vel, N, N, 2), Int((N - 1)/2)
end

function readVorticityFreqIC(file)
	qhat = readdlm(file, ',', Float64)
	N = Int( 1/2 * (-1 + sqrt(1 + 8*length(qhat))))
	return qhat, Int((N-1)/2)
end

# Computes curl of 2d vector field using central differences
function curl(u)
	N = size(u)[1]
	delta = 2*pi/N

	u1 = u[:,:,1]
	u2 = u[:,:,2]
	du1_dy = (circshift(u1, (0, 1)) - circshift(u1, (0, -1)))/(2*delta)
	du2_dx = (circshift(u2, (1, 0)) - circshift(u2, (-1, 0)))/(2*delta)
	return du1_dy - du2_dx
end

# Computes Biot-Savart law of a set of vorticity fourier coefs
# Slow!!! But there is an improvement coming soon
# 1. Order of loops matters, profile
# 2. On update step we only need to change 3 coefs per i,j (huge speedup)
function biotSavart(qhat)
	N = size(qhat)[2]
	maxFreq = Int((N-1)/2)
	vel = zeros(Complex, N, N, 2)
	for i=1:N
		for j=1:N
			for k1=-maxFreq:maxFreq
				for k2=-maxFreq:maxFreq
					if k1 >= 0
						qk = qhat[k1+1, mod(k2, N)+1]
					else
						qk = conj(qhat[-k1+1, mod(-k2, N)+1])
					end

					k=[k1, k2]
					x=[2*pi*i/N, 2*pi*j/N]
					if norm2(k) > 0 
						vel[i,j,:] += qk * perp(k)/norm2(k) * exp(1im * prod(k, x))
					end
				end
			end
		end
	end
	vel = real(1im/(2*pi) * vel)
	if any(isnan,vel)
		println("nan detected")
	end
	return vel
end

# Compute a dict of all triples j,k,l in [-N,N] such that j+k+l=0
function computeTriples(N)
	# Consider an immutable dict for speed
	triples = Dict{Int64, Tuple{Int64,Int64,Int64}}()
	counter = 1

	# Consider storing j,k,l in increasing order to save 6x space and some time
	# Only need to store half because of rfft properties
	for j = -N:N
		for k = -N:N
			l = - j - k
			if -N <= l <= N
				triples[counter] = (j,k,l)
				counter += 1
			end
		end
	end
	return triples
end


# Uniformly at random selects j,k,l in [-N, N]^2 such that j+k+l=(0,0)
function randomTriple(triples)
	j = Array{Int64}(undef, 2)
	k = Array{Int64}(undef, 2)
	l = Array{Int64}(undef, 2)

	X = rand(1:length(triples), 2)

	for i = 1:2
		j[i] = triples[X[i]][1]
		k[i] = triples[X[i]][2]
		l[i] = triples[X[i]][3]
	end
	return j, k, l
end

# Uniformly at random selects j,k,l in [-N, N]^2 such that j+k+l=(0,0)
# Does not require dictionary of triples
# "Good" runtime in expectation (no analysis done yet but easily > 50% chance of success)
function selectTripleRejectionSampler()
	# todo
	return 0
end


# Solves coupled ODE for time t
function evolve!(qhat, j, k, l, t)
	N = size(qhat)[2]

	C_jl = coef(j,l)
	C_lk = coef(l,k)
	C_kj = coef(k,j)

	if j[1] >= 0
		qj = qhat[j[1]+1, mod(j[2], N)+1]
	else
		qj = conj(qhat[-j[1]+1, mod(-j[2], N)+1])
	end

	if k[1] >= 0
		qk = qhat[k[1]+1, mod(k[2], N)+1]
	else
		qk = conj(qhat[-k[1]+1, mod(-k[2], N)+1])
	end

	if l[1] >= 0
		ql = qhat[l[1]+1, mod(l[2], N)+1]
	else
		ql = conj(qhat[-l[1]+1, mod(-l[2], N)+1])
	end

	# Verbose option?
	#println("j: ", j, ", k: ", k, ", l: ", l)
	#println("C_jl: ", C_jl, ", C_lk: ", C_lk, ", C_kj: ", C_kj)
	#println("qj: ", qj, ", qk: ", qk, ", ql: ", ql)


	tspan = (0.0, t)
	prob = ODEProblem(ODEsystem!, [qj, qk, ql], tspan, [C_jl, C_lk, C_kj])
	sol = solve(prob)

	qj, qk, ql = sol[end]

	if j[1] >= 0
		qhat[j[1]+1, mod(j[2], N)+1] = qj
	else
		qhat[-j[1]+1, mod(-j[2], N)+1] = conj(qj)
	end

	if k[1] >= 0
		qhat[k[1]+1, mod(k[2], N)+1] = qk
	else
		qhat[-k[1]+1, mod(-k[2], N)+1] = conj(qk)
	end

	if l[1] >= 0
		qhat[l[1]+1, mod(l[2], N)+1] = ql
	else
		qhat[-l[1]+1, mod(-l[2], N)+1] = conj(ql)
	end
end

# Coupled ODE
function ODEsystem!(dq, q, p, t)
	C_jl, C_lk, C_kj = p
	dq[1] = -conj(C_jl*q[2]*q[3])
	dq[2] = -conj(C_lk*q[1]*q[3])
	dq[3] = -conj(C_kj*q[1]q[2])
end

# Returns C_{l,j}
function coef(l,j)
	if l == [0,0] || j == [0,0]
		return 0
	end
	return (-j[2]*l[1] + j[1]*l[2])/(4*pi) * (1/norm2(l) - 1/norm2(j))
end

# Returns norm squared of a 2d vector
function norm2(j)
	return j[1]^2 + j[2]^2
end

# Returns inner product of 2d vectors
function prod(j,k)
	return j[1]*k[1] + j[2]*k[2]
end

# Returns perp of a 2d vector
function perp(j)
	return [-j[2], j[1]]
end